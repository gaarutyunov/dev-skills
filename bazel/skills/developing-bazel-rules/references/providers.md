# Provider Design Patterns

## Basic Provider Definition

Always define providers with explicit fields and documentation:

```python
MyLanguageInfo = provider(
    doc = "Information needed to compile MyLanguage code.",
    fields = {
        "sources": "depset of source Files",
        "compile_flags": "list of compilation flags",
        "transitive_deps": "depset of MyLanguageArchive for all transitive dependencies",
    },
)
```

## Transitive Information Pattern

Propagate information through the dependency graph using depsets:

```python
def _my_library_impl(ctx):
    # Collect transitive info from deps
    transitive_sources = depset(
        direct = ctx.files.srcs,
        transitive = [dep[MyInfo].transitive_sources for dep in ctx.attr.deps],
    )

    transitive_deps = depset(
        direct = [archive],
        transitive = [dep[MyInfo].transitive_deps for dep in ctx.attr.deps],
    )

    return [
        MyInfo(
            sources = depset(ctx.files.srcs),
            transitive_sources = transitive_sources,
            transitive_deps = transitive_deps,
        ),
    ]
```

## Compilation Archive Pattern

Separate compiled artifacts from source info (used by rules_go, rules_rust):

```python
# Raw source information
GoSource = provider(fields = {
    "srcs": "Source files",
    "deps": "Direct dependencies",
    "importpath": "Import path",
})

# Compiled artifact
GoArchive = provider(fields = {
    "source": "GoSource this was built from",
    "file": "Compiled .a file",
    "export_file": "Export data file",
    "data": "GoArchiveData for transitive use",
})

# Lightweight transitive data
GoArchiveData = provider(fields = {
    "file": "Archive file",
    "importpath": "Import path",
    "importmap": "Actual import path",
})
```

## Provider with Init Validation

Use init function for validation and preprocessing:

```python
def _my_info_init(*, sources, deps = None):
    if not sources:
        fail("sources cannot be empty")
    return {
        "sources": sources,
        "deps": deps or [],
    }

MyInfo, _new_my_info = provider(
    fields = ["sources", "deps"],
    init = _my_info_init,
)

# Usage:
info = MyInfo(sources = files)  # Goes through validation
raw = _new_my_info(sources = [], deps = [])  # Bypasses validation
```

## Multiple Providers Pattern

Return multiple providers for different consumers:

```python
def _my_library_impl(ctx):
    return [
        # Standard build info
        DefaultInfo(
            files = depset([archive.file]),
            runfiles = ctx.runfiles(files = ctx.files.data),
        ),

        # Language-specific compilation info
        MyLangInfo(
            archive = archive,
            transitive_deps = transitive_deps,
        ),

        # Coverage instrumentation info
        coverage_common.instrumented_files_info(
            ctx,
            source_attributes = ["srcs"],
            dependency_attributes = ["deps"],
        ),

        # Additional output groups
        OutputGroupInfo(
            compilation_outputs = [archive.file],
            _validation = [validation_output] if validation_output else [],
        ),
    ]
```

## Provider Merging Pattern

For aspects or rules that need to combine providers:

```python
def _merge_my_info(infos):
    """Merge multiple MyInfo providers into one."""
    return MyInfo(
        sources = depset(transitive = [i.sources for i in infos]),
        compile_flags = [f for i in infos for f in i.compile_flags],
    )
```

## Aspect Provider Pattern

Aspects return providers that augment the target:

```python
MyAspectInfo = provider(fields = {"generated": "Files generated by aspect"})

def _my_aspect_impl(target, ctx):
    # Access original target's providers
    original_srcs = target[MyInfo].sources

    # Create new outputs
    output = ctx.actions.declare_file(target.label.name + ".gen")

    return [MyAspectInfo(generated = depset([output]))]
```

## Conditional Provider Pattern

Return different providers based on rule configuration:

```python
def _impl(ctx):
    providers = [DefaultInfo(files = depset([output]))]

    if ctx.attr.generate_proto:
        providers.append(ProtoInfo(...))

    if ctx.attr.testonly:
        providers.append(TestInfo(...))

    return providers
```

## Provider Documentation Best Practices

1. **Always use `fields` dict** - enables documentation generation
2. **Document each field** - explain type and purpose
3. **Use depsets for collections** - enables efficient merging
4. **Separate transitive from direct** - clearer API
5. **Define separate provider for archives** - keeps compilation data separate
